# 컨셉

이 저장소는 다른 프로젝트에서 사용할 공용 패키지입니다.

## 목표

타 프로젝트에서 subtree로 사용한다.

타 프로젝트에서 본 프로젝트로 PR을 할 수 있다.

본 프로젝트 독자적으로 로컬 개발 환경 가동 및 테스트가 가능하다

## 🔧 브랜치 운영 전략 - 공유용 브랜치(main) / 테스트용 브랜치(dev) 분리 전략

독자적인 테스트를 하면서도, 타 프로젝트에서 실질적으로 사용할 패키지만 받기 위해서는 본 프로젝트에서 테스트 코드와 패키지 코드를 분리해서 관리해야 합니다.

이 저장소는 아래와 같이 **브랜치 분리 전략**을 사용합니다.

### 브랜치 역할

1. **`main` 브랜치**

   - 다른 프로젝트에서 subtree 방식(`git subtree`)으로 공유할 파일만 포함합니다.
   - 예: `src/`, `index.ts`, `tsconfig.json` 등
   - 테스트 코드, 문서, 스토리북, 설정 파일 등은 포함하지 않습니다.

2. **`dev` 브랜치**
   - 독자적인 개발 및 테스트 작업을 수행할 수 있는 브랜치입니다.
   - main 브랜치에서 관리하는 공유용 패키지 외에 테스트 코드(`test/`), 스토리북(`.storybook/`), 문서 등을 포함합니다

### 브랜치 운영 전략

실무에서는 다음같이 사용합니다.

1. 본 프로젝트를 독자적으로 로컬에서 가동 및 테스트, 개발하는 건 dev 브랜치를 사용합니다.

2. 타 프로젝트에서 공유 패키지를 사용할 때에는 본 프로젝트의 main 브랜치를 기준으로 패키지를 가져옵니다.

3. PR은 자신이 바라보는 브랜치를 기준으로 합니다.

dev 브랜치에서의 변경 사항은 동일하게 dev로 반영하고, 타 프로젝트에서 공유 패키지를 수정하면 본 프로젝트의 main 브랜치에 PR합니다.

4. 둘 간에 동기화 작업을 수행하고 git 이력으로 남깁니다.

두 브랜치 각자에 들어온 커밋은 주기적으로 동기화하여 충돌을 방지합니다.

# 사용 시작하기

## 타 프로젝트에서 사용하는 경우

타 프로젝트에서 공유 패키지를 subtree로 받아오고, 수정하며 본 프로젝트의 원격 레포지토리에 반영하는 방법은 다음과 같습니다.

### 1. 공유 패키지의 원격 저장소를 remote로 추가 (한 번만)

먼저, 공유 패키지 저장소를 원하는 이름으로 등록합니다.

예시로 저는 `shared-origin`으로 등록해보겠습니다.

```bash
git remote add shared-origin https://github.com/charchar111/subtree-test2.git
```

### 2. 공유 패키지 저장소의 main 브랜치를 subtree로 가져오기

#### 2-a. 최초에 가져오는 경우

공유 패키지 저장소의 main 브랜치를 subtree로 등록합니다.

등록을 위해서는 가져올 파일의 위치를 설정해야 합니다.

아래 커맨드를 봐주세요

```bash
git subtree add --prefix=shared shared-origin main --squash
```

##### subtree 명령어 옵션 설명

- `--prefix` 로 가져올 위치를 설정합니다.

- `shared-origin`은 원격 레포지토리, `main`은 해당 레포지토리에서 가져올 브랜치입니다

- `--squash`는 가져올 브랜치의 커밋을 압축해서 가져오는 옵션입니다. 레포지토리의 git 변경 내역이 공유 패키지와 섞이지 않도록 해줍니다.

#### 2-b. 이미 등록한 subtree에 원격 레포지토리의 변경사항을 갱신하는 경우

만약 이미 공유 패키지를 subtree로 등록한 상황이고 최신 변경 사항을 갱신하는 경우라면 아래처럼 최신화 가능합니다.

```bash
git subtree pull --prefix=shared shared-origin main --squash
```

자세한 옵션은 위의 [subtree 명령어 옵션 설명](#subtree-명령어-옵션-설명)을 참고하세요

**여기까지 완료되었다면 공유 패키지를 사용할 수 있습니다. 아래는 공유 패키지를 수정하고 원래 원격 저장소에 PR하는 방법입니다.**

---

### 3. A 프로젝트 내에서 shared 코드 수정 및 커밋

만약 공유 패키지 코드를 직접 수정하고 변경사항을 다른 사람에게 공유하고자 한다면
아래처럼 subtree가 있는 위치의 변경사항을 수동으로 추가하고 커밋을 만들어주세요

```bash
# shared는 subtree가 추가된 위치이며, 알맞게 바꿔주세요
git add shared/
git commit -m "fix: 공유 패키지 수정"
```

### 4. 수정 사항을 shared 저장소의 main 브랜치로 푸시

간단한 방식과, 리뷰 및 이력 관리에 유리한 방식이 있습니다.

#### 기본 방식

변경사항을 subtree 레포에 push할 때 자동으로 처리하는 방식입니다.

간단하지만, PR의 커밋이 squash 될 수 있습니다.

즉, 100개의 커밋이 하나로 압축되면서 제대로 리뷰를 하기 어려울 수 있습니다.

또한, 이력이 병합되면서 개별 변경 사항을 파악할 수 없습니다

간단하지만, 엄격한 PR 리뷰와 개별 변경 사항 확인에는 적합하지 않습니다.

```bash
git subtree push --prefix=shared <원격 서브 레포> <브랜치명>
# 원 레포의 트리에서 shared 내 변경사항만 서브 트리 레포의 브랜치에 반영함
```

#### 리뷰 및 이력 관리에 유리한 방식: split 사용하기

프로젝트 내 전체 변경사항 중 공유 패키지의 변경사항만을 따로 추출하여 별도의 브랜치를 만들고 공유 패키지의 저장소로 PR하는 방식입니다.

PR의 커밋을 살리기 좋습니다.

즉, 100개의 커밋을 전부 분리하여 살려 보낼 수 있습니다.

"어떤 파일이 어떻게 바뀌었는지", "누가 커밋했는지", "리뷰 승인" 이 가능합니다.

```bash
# 서브트리 디렉토리의 변경사항만 정제하여 split-subtree 브랜치로 추가
git subtree split --prefix=shared -b split-subtree

# git push  <원격 서브트리레포> <스플릿 브랜치>:<원격 서브트리 레포의 브랜치>
git push  subtree1 split-subtree:main

# 사용 후 해당 브랜치는 삭제
```

## 독자적으로 공유 프로젝트 개발을 하는 경우

중요한 건, dev 브랜치와 그 서브 트리 브랜치인 main 브랜치 간에 동기화 입니다.

### dev => main으로 동기화

dev 브랜치에서 서브트리가 추가된 폴더(eg : ./src)의 변경사항을 main으로 반영하려면 다음 명령을 씁니다.

```bash
git subtree push --prefix=src . main
```

### main => dev으로 동기화

```bash
git subtree pull --prefix=src . main
```

# 고급

## 메타 파일 관리

이론상 main은 실질적 공유 패키지, dev는 그 외의 모든 테스트 및 로컬 개발용 파일이라 구분했습니다만,
독립적인 빌드 및 배포가 가능하기 위해서는 main에도 공유를 위한 최소한의 환경 구성용 meta 파일이 포함됩니다.

메타 파일 종류는 아래와 같습니다.

### 중요도: 필수

#### gitignore

main 브랜치를 커밋할 때 불필요한 파일을 제외하는 목적입니다.

main과 dev를 git checkout으로 오고 갈때 git은 두 브랜치 간에 차이를 비교하여 파일을 수정 및 추가, 삭제합니다.
하지만, untrack file로 설정된 것들은 이런 수정 작업이 이뤄지지 않는데, 대표적으로 node_modules는 main으로 checkout을 하여도 그대로 남아있습니다.

만약, gitignore이 없다면 이런 파일들이 그대로 원격 저장소에 올라가버리니, 이를 방지하기 위해 main에 별도의 gitignore이 필요합니다.

- git은 프로젝트 내 모든 gitignore을 통합하여 제외할 파일을 선별합니다. gitignore은 기본적으로 자기 위치의 하위에 모든 디렉토리에 적용되다가, 다른 gitignore을 만나면
  해당 설정을 국소적으로 적용하는 방식입니다. (예컨대, ./src/asset/.gitignore은 ./,gitignore과 별개로 .src/asset/ 내에서만 작동합니다)

#### package.json

이 파일은 공유 패키지가 어떤 의존성을 사용하는지 명시하기 위해 필요합니다.

본 프로젝트에서 최상위 package.json이 존재하고, src에도 하나 존재합니다.

다른 프로젝트에서 main 을 subtree로 추가할 때에도 package.json이 함께 들어갑니다.

- package.json 없이 README로 의존성을 명시하고 사용자가 수동으로 복사 붙여넣기하여 의존성을 추가할 수도 있으나, 매번 갱신하기가 번거로워 폐기하였습니다.

##### 사용 방법

패키지를 사용할 프로젝트의 최상단 package.json에 서브 트리 폴더를 workspace로 추가하세요.

##### 의존성 중복 제거 및 버전 충돌 관리

workspace 는 모노레포 구조에서 하위 프로젝트의 의존성을 관리하는 대표적인 방식이며, 레퍼런스가 많고 안정적입니다.
버전 충돌 발생 시 루트를 기준으로 설치하고, 설치를 중단하거나 회피 하는 대신 경고만 합니다. 예컨대, 루트 프로젝트는 의존성으로 react ^19, 하위 프로젝트는 react ^18을 요구한다면 npm i 시 reacy 19로 설치하되, 충돌 경고(could not resolve dependency) 가 콘솔에 뜹니다.

만약 상위 프로젝트와 하위 프로젝트 간에 의존성이 중복된다면 하나로 통합합니다.

**예시**

```bash

# 워크 스페이스로 추가할 폴더명. 여기서는 subtree를 추가
  "workspaces": [
    "srcs"
  ],
```

#### tsconfig.json

tsconfig도 상위와 하위 디렉토리에 tsconfig.json이 각각 있어도 문제 없습니다.
컴파일 시 가장 가까운 tsconfig를 기준으로 적용되므로, 하위 프로젝트는 가장 가까운 tsconfig 사용합니다

그러면 하위 프로젝트에서 tsconnfig를 설정할 떄에는 별도로 상위 프로젝트에서 설정할 거는 없습니다.

**단, path alias 처럼, 번들링과 직접 관련이 있는 세팅은 상위 프로젝트의 vite.config.ts 같은 번들링 세팅에 직접 포함시켜줘야 합니다.**

#### README.md

main 프로젝트 전용 doc 입니다.
dev와 main에 동일한 것을 수동으로 복사 붙여넣기 합니다.

#### index.ts

배럴 익스포트 전용 파일입니다.

공유 패키지의 내부 디렉토리 구조가 변경되더라도 index.ts를 통해서만 import와 export가 이뤄진다면 경로 오류가 발생하지 않습니다.

##### 고도화 방침(TODO)

- CLI 기반 자동화

- linting 설정

- 사용 DOC 정리

### 중요도: 선택사항

#### vite.config.ts

일반적으로 vite 설정은 하위 프로젝트에서 독립적으로 가지고 있을 필요가 없습니다. 하지만, 공유 패키지만에 고유한 번들링 세팅이 필요하다면 별도로 만드는 것이 좋습니다.
예컨대, 독자적인 path alias 방식을 쓴다거나 최적화 전략 등이 필요하다면 말입니다.

하지만, 이 방법은 몇 가지 복잡함을 만들어 냅니다.

- 부모와 자식 간에 path alias를 수동으로 맞춰야 할 수 있습니다.

- 부모와 자식 프로젝트가 동일한 의존성을 중복으로 내장하지 않도록 공유 설정을 해야 할 수 있습니다. 이 경우, external 옵션을 사용해야 합니다.

  - - 만약 하위에서 external로 따로 뺀 라이브러리가 상위에 없으면 런타임에 에러 발생(referenceError나 Module not found)

  - - 이 경우, package.json에 peerDependency를 명시하여 상위에 필수 라이브러리를 알릴 수 있다고 gpt가 말하는데, 잘 되는지는 모르겠습니다.
